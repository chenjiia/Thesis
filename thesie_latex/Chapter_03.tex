\chapter{Experiment with Getafix}
	\label{CH_03}

\marginpar{(why and what other property are there)}
We want to use model-checking tools to see if we can reduce the time requirement of algorithm \ref{code:doubleLoop}. Specifically, we choose the reachability property and append algorithm \ref{code:reachLine} to the end of algorithm \ref{code:doubleLoop}. The statement within the if statement has a label. Although the exact statement following that label is irrelevant, reaching this line means $OCounter$ satisfies the constrains in the condition block.

\marginpar{correct citations of web page}
We experimented on several model-checking tools, including Interproc from \cite{_interproc_2011}, Berkeley Lazy Abstraction Software Verification Tool(Blast) from \cite{_mtc_2008} and Getafix from \cite{la_torre_analyzing_2009}. We can not get correct reachability results from Interproc and Blast, so we shift our focus on Getafix.

\renewcommand{\algorithmiccomment}[1]{// #1}
\begin{algorithm}
\begin{algorithmic}

\IF{value of $OCounter$ meets certain constrains}
\STATE reach: $OCounter$
\COMMENT{a label followed by a statement}
\ENDIF

\end{algorithmic}

\caption[Single loop]{Determine if $OCounter$ meets certain constrains.}
\label{code:reachLine}
\end{algorithm}

\section{Getafix}
Getafix is a symbolic model checker for Boolean programs implemented in \cite{la_torre_analyzing_2009}. Getafix only supports reachability check. It translates sequential and concurrent Boolean programs into Boolean formulae and uses the model-checker Mucke to solve the reachability problem symbolically using Boolean Decision Diagrams \cite{_getafix_2009}. 
\marginpar{Mostly copied from getafix website. Need rewrite}

\section{The converter}
Input for Getafix are boolean programs, meaning it only supports binary variables which can be either 0 or 1. We represent our problem in c-style code, thus we need to translate it into boolean form. We implemented a converter to automate this process. The converter has three components, a parser, a built-in function generator and a piece of script which calls the first two components and assemble the output file.

Input to the parser is the c-style code file and the desired bit length. Output of the parser is its corresponding boolean program which follows the syntax of Getafix input file. First we define the syntax of input code to the parser and second we create the parser using flex and bison. The parser scans the input code and builds a syntax tree. Then the parser prints the syntax tree as a boolean program. The parser has three points worth noting:

\begin{enumerate}
\item When printing the output code, the parser ``stretches'' each variable and literal into its binary form. Assume the desired bit length is $bitLength$. We split each variable into $bitLength$ variables by copying the name of the variable $bitLength$ times and append a counter value to each one. Also we convert a literal to its corresponding binary value and prepend it with zeros to reach the desired length.
\item In a boolean program, all operators operate on bit level, so we need to implement higher-level operators like plus, minus, greater than and left shift using operators that Getafix supports. In the parser, we print these high-level operators as function calls in the output boolean program, and the built-in function generator generates the body of the function.
\item In the boolean code syntax which Getafix defines, function call plus the semicolon is defined as a statement, and another rule allows the code to assign a function call to an identifier, but function call itself is not an expression. This means that a function call can not work as an expression as in many other languages, and it leads to two problems: First, the decider expression in if...else and while statements can not contain function calls. Second, parameters of a function call or operands to an operator can not be a function call. We automated a solution in the parser to the first problem, which assigns the decider expression to a temporary variable and use that variable as the decider, so we can use the c-style if...else and while in the input code. For the second problem, a possible solution would be to manage a set of internal temporary variables and assign each function call to a variable, but we did not implement it.
\end{enumerate}

Input to the built-in function generator is the desired bit length. Output is a set of high-level operators like plus and left shift implemented as functions. We do not track the necessary functions in the parser, as experiments with Getafix indicate that the uncalled functions affect little on the execution time. Listing \ref{lst:isGT} shows a sample function by the generator, and table \ref{tbl:fxNames} shows all the operators supported by the converter.

\lstset{language=C}  
\begin{lstlisting}[caption={Greater than operator as a function in boolean program with bit length of 2.},label=lst:isGT]
bool isGT(left2,left1,left0,right2,right1,right0)
begin
if (left2 != right2) then
	if (left2 = 1) then
		return 1;
	fi
else 
	if (left1 != right1) then
		if (left1 = 1) then
			return 1;
		fi
	else 
		if (left0 != right0) then
			if (left0 = 1) then
				return 1;
			fi
		fi
	fi
fi
return 0;
end
\end{lstlisting}
\begin{table}[h]
\caption{Built-in function names and corresponding operators}
\label{tbl:fxNames}
\begin{tabular}{|l|l|}
\hline
Function name & Operator in input code   \\ \hline
plus          & +                        \\ \hline
minus         & -                        \\ \hline
and           & \&                       \\ \hline
or            & |                        \\ \hline
xor           & \textasciicircum         \\ \hline
isGT          & \textgreater             \\ \hline
isNotEqual    & !=                       \\ \hline
isEqual       & ==                       \\ \hline
isGTEQ        & \textgreater=            \\ \hline
isLT          & \textless                \\ \hline
isLTEQ        & \textless=               \\ \hline
lShift        & \textless\textless       \\ \hline
rShift        & \textgreater\textgreater \\ \hline
\end{tabular}
\end{table}
\section{Tests and results}
\subsection{Sanity check}

