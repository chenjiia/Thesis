\chapter{Theory background}
	\label{CH_02}

\section{Min-entropy}
The introduction counts as chapter 1.  This page shows how the bulk of your thesis will be organized: through chapters and sections. Here is a citation.\cite{OBTMBD01}

\section{Information leak}

\section{Two intuitive solutions}
To count the number of outputs of a program, we come up with two approaches: Put the program in a double loop and count the number of outputs, or let the program iterate through all input values and record the outputs in an array. The first approach is time-consuming, while the second one is space-consuming.

\subsection{Double loop and counter}
In algorithm \ref{alg:doubleLoop}, for each possible output value, we iterate through the input range to see if an input can result in this output. If we hit such an input, counter increases and the code breaks out of the inner loop to continue testing the next possible output value. After the double loop finishes, the value of $OCounter$ is the number of outputs of program $P$.

\begin{algorithm}
\begin{algorithmic}
\renewcommand{\algorithmiccomment}[1]{// #1}
\STATE $S \leftarrow 0$
\STATE $O \leftarrow 0$
\STATE $SIn \leftarrow 0$
\STATE $OOut \leftarrow 0$
\STATE $OCounter \leftarrow 0$

\STATE $SMax \leftarrow 1 << bitLength - 1$
\STATE $OMax \leftarrow 1 << bitLength - 1$

\FOR{$O=0$ to $OMax$}
\FOR{$S=0$ to $SMax$}
\STATE $SIn \leftarrow S$ 
\STATE $OOut \leftarrow P(SIn)$ 
\COMMENT{the program $P$ takes $SIn$ as input}
\IF{$OOut = O$}
\STATE $OCounter \leftarrow OCounter + 1$
\STATE break
\ENDIF
\ENDFOR
\ENDFOR
\end{algorithmic}

\caption[Double loop]{Calculate the number of outputs using double loop.}
\label{alg:doubleLoop}
\end{algorithm}

In algorithm \ref{alg:doubleLoop}, we declared seven variables, and all of them require $bitLength$ bits except for $OCounter$ which is $bitLength + 1$ bits. The total memory usage for variables is $7 \times bitLength + 1$ at $O(bitLength)$. As with execution time, we assume program $P$ takes time $t(P)$ to execute, and the total execution time for the double loop when break is never reached is $2^{bitLength} \times 2^{bitLength} \times t(P)$. Thus the time complexity is $(2^{O(bitLength)}) \times t(P)$.

In order to get an estimation of how much time the double loop will take to execute, we implemented a piece of C code with an empty while loop which loops $2^{32}$ times. On out experiment PC, this loop takes on average $10.30$ seconds to complete. Were we to run a double loop in bit length of 32, the execution time would be $2^{32} \times 10.30$ seconds, which is around $1403$ years. Running the double loop directly would be infeasible.

\subsection{Single loop and array}
In algorithm \ref{alg:singleLoop}, we create an array with size equal to the maximum number of possible outputs($1 << bitLength$, or $2^{bitLength}$) and initialize it with zeros. While we iterate through the range of $S$, we set each $OHit[P(SIn)]$ to $1$. When a $0$ turns to $1$, we increase $OCounter$. After the loop, the value of $OCounter$ is the number of outputs by program $P$. 

\renewcommand{\algorithmiccomment}[1]{// #1}
\begin{algorithm}
\begin{algorithmic}

\STATE $S \leftarrow 0$
\STATE $O \leftarrow 0$
\STATE $SIn \leftarrow 0$
\STATE $OOut \leftarrow 0$
\STATE $OCounter \leftarrow 0$

\STATE $SMax \leftarrow 1 << bitLength - 1$
\STATE $OMax \leftarrow 1 << bitLength - 1$
\STATE $OHit[OMax + 1] \leftarrow [0]$

\FOR{$S=0$ to $SMax$}
\STATE $SIn \leftarrow S$ 
\STATE $OOut \leftarrow P(SIn)$ 
\COMMENT{the program $P$ takes $SIn$ as input}
\IF{$OHit[OOut] = 0$}
\STATE $OCounter \leftarrow OCounter + 1$
\STATE $OHit[OOut] \leftarrow 1$
\ENDIF
\ENDFOR

\end{algorithmic}

\caption[Single loop]{Calculate the number of outputs using single loop and a table.}
\label{alg:singleLoop}
\end{algorithm}

In algorithm \ref{alg:singleLoop} except for the array we have 7 variables using $7 \times bitLength + 1$ memory. The array $OHit[]$ is of size $2^{bitLength} \times bitLength$ making a total of $2^{bitLength} \times bitLength + 7 \times bitLength + 1$ at $2^{O(bitLength})$. As with execution time, we assume program $P$ takes time $t(P)$ to execute, and the execution time for the single loop is $2^{bitLength} \times t(P)$. Thus the time complexity is $(2^{O(bitLength)}) \times t(P)$.

\marginpar{if this is not hard we need reasons not doing this..}
We set the bit length to $32$. In array $OHit[]$, each element is $32$ bits and the number of elements is $2^{32}$. The total memory usage for this array is $2^{32} \times 32$ bits, which is $16$ gigabytes. To our knowledge, it is neither difficult nor expensive to build a PC with more than 16 gigabytes of memory, and we can get such a PC off-the-shelf from top gaming PC brands like Alienware. However, as this memory requirement grows exponentially, adding two to three bits to the bit length and the requirement will exceed the capacity of current PCs.